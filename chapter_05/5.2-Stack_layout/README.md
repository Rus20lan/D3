# Создание стековых диаграмм

**Потоковый график** - это разновидность известной составной столбчатой диаграммы.
Потковый график - это **стековая диаграмма**, т.е. в своей основе он похож на стековые столбчатые диаграммы. Потоковые графики также похожи на **область размаха** позади линейной диаграммы, за исключением того, что в потоковом графике эти области накладываются друг на друга.
В этом разделе мы воспользуемся генераторами стека и областей размаха и с их помощью создадим стековую столбчатую диаграмму, за которой следует потоковый график.

## Шаги создания составной столбчатой диаграмыы с помощью D3

1. **_Обработать данные с помощью стекового макета_**
   а. Отформатировать данные.
   б. Инициализировать стековый макет вызовом d3.stack().
   в. Если данные отформатированы как массив объектов, то использовать функцию доступа keys(), чтобы указать ключ, в котором содержатся значения для стека.
   г. Вызвать стековый макет, чтобы получить набор данных, дополненный нижней и верхней границами каждой серии.
2. **_Инициализировать генератор областей размаха (необязательно)_**
3. **_Нарисовать стопки фигур_**. Связать аннотированный набор данных, сгенерировать на шаге 1, с фигурами SVG. Для потокового графика вызвать генератор областей, чтобы вычислить атрибуты d элементов path.

## Генератор стекового макета

**Генератор стекового макета** - это функция D3, которая принимает набор данных с несколькими категориями. Функция стекового макета возвращает новый, аннотированный набор данных, содержащий координаты различных серий, "сложенных" одна над другой. Этот генератор является частью модуля **d3-shape**.

В следующем фрагменте мы объявляем **генератор стекового макета** вызовом метода **d3.stack()** и сохраняем его в константе с именем **stackGenerator**. Затем сообщаем генератору, какие ключи из набора данных сожержат значения для стековой диаграммы(которые станут серией). Для этого вызывается функция доступа **keys()**, которой передается массив идентификаторов каждого насителя музыки. Этот массив создается отображением идентификаторов из константы **formatsInfo**.
Наконец, мы вызываем генератор стека и передаем ему исходные данные для получения аннотированного набора, который сохраняем в константе с именем **annotatedData**

```js
// prettier-ignore
// Инициализировать генератор стекового макета
const stackGenerator = d3.stack()
  .keys(formatsInfo.map(format => format.id));

const annotatedData = stackGenerator(data);
```

## Рисование составной столбчатой диаграммы

**Составные столбчатые диаграммы** похожи на обычные столбчатые диаграммы (гистограммы), только в данном случае столбцы разделены на несколько категорий, или серий. Составные столбчатые диаграммы и составные визуализации в целом часто используются для отображения развития тенденций с течением времени.

Объявление вертикальной шкалы

```js
// prettier-ignore
const maxUpperBoundary = d3.max(annotatedData[annotatedData.length - 1], d => d[1]);
const yScale = d3
  .scaleLinear()
  .domain([0, maxUpperBoundary])
  .range([innerHeight, 0])
  .nice();
```

Теперь можно добавлять столбцы. Для этого выполним обход аннотированных данных в цикле и добавим серии одну за другой.

```js
// prettier-ignore
annotatedData.forEach(series =>{
    innerChart
      .selectAll(`.bar-${series.key}`)
      .data(series)
      .join('rect')
        .attr("class", d => `bar-${series.key}`)
        .attr("x", d => xScale(d.data.year))
        .attr("y", d => yScale(d[1]))
        .attr("width", xScale.bandwidth())
        .attr("height", d => yScale(d[0]) - yScale(d[1]))
        .attr("fill", colorScale(series.key));

  });
```

Добавление промежутка между столбцами (scales.js)

```js
xScale
  .domain(data.map((d) => d.year))
  .range([0, innerWidth])
  .paddingInner(0.2);
```

Завершая составную столбчатую диаграмму, добавим оси. Сначала объявляем нижнюю ось с помощью метода **d3.axisBottom()** и передаем шкаду **xScale**.
В цепочку объявления оси мы добавили метод **.tickValues()**, чтобы указать, какие риски и метки должны быть видны на диаграмме. Метод **tickValues()** принимает массив значений, который мы генерируем с помощью метода **d3.range()** и указываем, что нам нужно каждое целое число с 1975 по 2020 год с шагом 5.
Мы также скрываем риски на концах нижней оси с помощью метода **.tickSizeOuter()**, которому передаем значение **0**.

```js
// prettier-ignore
const bottomAxis = d3.axisBottom(xScale)
    .tickValues(d3.range(1975, 2020, 5))
    .tickSizeOuter(0);

innerChart
  .append('g')
  .attr('transform', `translate(0, ${innerHeight})`)
  .call(bottomAxis);

const leftAxis = d3.axisLeft(yScale);
innerChart.append('g').call(leftAxis);
```

## Рисование потокового графика

В потоковых графиках аннотированный набор данных используется для создания областей размаха, в то время как составных столбчатых иаграммах создаются прямоугольники.

Объявление генератора стекового макета

```js
// prettier-ignore
const stackGenerator = d3.stack()
  .keys(fortmatsInfo.map(f => f.id));
const annotatedData = stackGenerator(data);
const maxUpperBoundary = d3.max(
  annotatedData[annotatedData.length - 1],
  (d) => d[1]
);
const yScale = d3
  .scaleLinear()
  .domain([0, maxUpperBoundary])
  .range([innerHeight, 0])
  .nice();
```

В следующем фрагменте мы инициализируем генератор области **d3.area()**. Сначала используем его функцию доступа **x()** для вычисления горизонтальной координаты каждой точки данных. Поскольку **xScale** - это интервальная шкала, она возвращает координату начала каждого интервала для каждого года, имеющегося в аннотированном наборе данных в объекте **data** каждой точки данных (**d.data.year**).

```js
// prettier-ignore
const areaGenerator = d3.area()
  .x(d => xScale(d.data.year) + xScale.bandwidth() / 2)
  .y0(d => yScale(d[0]))
  .y1(d => yScale(d[1]))
  .curve(d3.curveCatmullRom);
```

Теперь можно начинать рисовать составные области. Мы вызываем функцию генератора областей, чтобы получить атрибут **d** каждого элемента **path**, и вызываем цветовую шкалу для настройки их атрибута **fill**.

```js
// prettier-ignore
innerChart
  .append("g")
    .attr("class", "area-container")
  .selectAll("path")
  .data(annotatedData)
  .join("path")
    .attr("d", arcGenerator)
    .attr("fill", d => colorScale(d.key));
```

## Превращение рисок на оси в сетку
