# Рисование линий и дуг

Для создания более сложных визуализаций мы обычно используем **кривые** SVG.
**Кривые** - это самые гибкие из элементов SVG, способные принимать приктически любую форму.
**Форма кривой** SVG **определяется** её атрибутом **d**. Этот **атрибут** содержит строку с последовательностю команд, определяющих **_начальную_** и **_конечную_** точки кривой, **\*типы кривых**, которые используются для изменения направления, и признак замкнутости кривой. Атрибут **d** может быть очень длинным и сложным. Но в большинстве случаев мы не пишем его сами, а используем **генераторы фигур**, имеющиеся в D3!

## Соглашение о границах и отступах

Соглашение о границах и отступах, принятое в D3, определяет общий порядок резервирования пространства вокруг диаграммы для осей меток и легенд. В этом соглашении определяется четыре поля отступов: **_сверху, справа, снизу_** и **_слева_** от диаграммы.
Значения отступов объявляются в объекте с атрибутами **_top, right, bottom_** и **_left_**. Внутри функции **drawLineChart()** объявим константу с именем **margin** и присвоим атрибутам **_top, right, bottom_** и **_left_** значения **_40, 170, 25_** и **_40_** соответственно:

```js
// prettier-ignore
const drawLineChart = (data) => {
  const margin = { top: 40, right: 170, bottom: 25, left: 40 };
  // Определение размера контейнера
  const width = 1000;
  const height = 500;
  const innerWidth = width - margin.right - margin.left;
  const innerHeight = height - margin.top - margin.bottom;
};
```

После определения отступов, можно вычислить размеры так называемой **внутренней диаграммы**.
**Внутренняя диаграмма** - это оставшиеся пространство в контейнере SVG для ядра диаграммы.
Создадим в методе **drawLineChart()** две константы: ширину (**innerWidth**) и высоту (**innerHeight**) внутренней диаграммы:

```js
// prettier-ignore
const drawLineChart = (data) => {
  const margin = { top: 40, right: 170, bottom: 25, left: 40 };
  // Определение размера контейнера
  const width = 1000;
  const height = 500;
  const innerWidth = width - margin.right - margin.left;
  const innerHeight = height - margin.top - margin.bottom;
};
```

Теперь добавим контейнер SVG для нашей линейной диаграммы. Элемент SVG добавим в **_div_** с идентификатором **line-chart**, и настроим его атрибут **viewBox**, используя константы **width** и **height**.

```js
// prettier-ignore
const svg = d3.select('#line-chart')
  .append("svg")
  .attr("viewBox", `0, 0, ${width}, ${height}`);
```

Чтобы реализовать стратегию смещения точки начала координат с учетом заданных отступов, добавим группу в контейнер SVG, применим к ней операцию переноса (**translate(margin.left, margin.top)**), опираясь на размеры отступов слева и сверху, и сохраним группу в константу с именем **innerChart**, которую позднее будем использовать для построения линейной диаграммы:

```js
// prettier-ignore
const innerChart = svg
  .append("g")
  .attr("transform",`translate(${margin.left}, ${margin.top})`);
```

## Генерирование осей

**Оси** - неотъемлемая часть большинства визуализаций данных, играют роль справки для зрителя, чтобы тот мог понять представленные числа и категории.
В D3 оси создаются с помощью генератора компонентов **axis()**. Он принимает шкалу и возвращает элементы SVG, составляющие ось.

### Объявление шкал

Прежде всего нам нужна шкала, располагающая даты по горизонтали. Это действие выполняет **d3.scaleTime()** - шкала времени в D3.
Предметная область шкалы простирается от первой (**_firstDate_**) до последней (**_lastDate_**) даты в наборе данных.
Диапазон шкалы простирается вдоль доступного горизонтального пространства во внутренней диаграмме, т.е от **_0_** до **_innerWidth_**.

```js
// prettier-ignore
const firstDate = d3.min(data, (d) => d.date);
const lastDate = d3.max(data, (d) => d.date);
const xScale = d3
  .scaleTime()
  .domain([firstDate, lastDate])
  .range([0, innerWidth]);
```

Для распределения температур вдоль оси **y** тоже нужна шкала с непрерывным входом и выходом. В данном случае идеально подходит линейная шкала, поскольку нам нужно, чтобы температура и вертикальное положение на линейной диаграмме были линейно пропроциональны.
Следующий фрагмент объявляет температурную шкалу с именем **yScale**. Наша ось **y** должна начинаться с 0, поэтому в качестве минимального значения предметной области мы передаем 0. В качестве максимального предметного значения мы передаем максимальную температу из набора данных. Это значение извлекается из столбца **_max_temp_F_** в наборе данных с помощью функции **d3.max()**.
Диапазон шкалы простирается вдоль доступного вертикального пространства высоты во внутренней диаграмме, а поскольку вертикальные значения вычисляются в системе координат SVG сверху вниз, диапазон начинается с **innerHeight** (позиции нижнего левого угла внутренней диаграммы) и заканчивается 0 (позицией верхнего левого угла):

```js
// prettier-ignore
const maxTemp = d3.max(data, d => d.max_temp_F);
const yScale = d3.scaleLinear().domain([0, maxTemp]).range([innerHeight, 0]);
```

### Добавление осей

После инициализации шкал можно добавить оси. В D3 есть четыре генератора осей - **axisTop()**, **axisRight()**, **axisBottom** и **axisLeft()**, - которые создают компоненты верхней, правой, нижней и левой осей соответственно.
Функции-генераторы осей принимают шкалу на входе. Чтобы создать, нижнюю ось для нашей диаграммы, нужно вызвать генератор **axisBottom()** и передать ему шкалу **xScale**.
Сохраним результат работы генератора в константе с именем **bottomAxis**:

```js
const bottomAxis = d3.axisBottom(xScale);
```

**_Генератор осей_** - это функция, создающая элементы, которые составляют ось. Чтобы эти элементы появились на экране, нужно применить **_генератор осей_** к выборке D3 с помощью метода **call()**.

```js
// prettier-ignore
innerChart
  .append('g')
    .attr('class', 'axis-x')
    .call(bottomAxis);
```

По умолчанию оси D3 отображаются в начале системы координат выборки - в данном случае в верхнем левом углу внутренней области диаграммы. Чтобы переместить ось вниз, нужно сместить группу SVG, содержащую эту ось. В следующем фрагменте смещаем группу, содержащую элементы оси, вниз на величину высоты внутренней диаграммы:

```js
// prettier-ignore
const bottomAxis = d3.axisBottom(xScale);

innerChart
  .append('g')
  .attr('class', 'axis-x')
  .attr('transform', `translate(0,${innerHeight})`)
  .call(bottomAxis);
```

Также нам нужно изменить форматирование меток осей.
При желании формат меток при рисках на осях можно изменить с помощью метода **axis.tickFormat()** из модуля d3-axis.
**_Риски_** - это короткие черточки на оси.

```js
// prettier-ignore
const bottomAxis = d3.axisBottom(xScale)
  .tickFormat(d3.timeFormat("%b"));
```

Также метки на оси х можно расположить по середине рисков

```js
// prettier-ignore
d3.selectAll('.axis-x text')
    .attr('x', (d) => {
      const currentMonth = d;
      const nextMonth = new Date(2021, currentMonth.getMonth() + 1, 1);
      return (xScale(nextMonth) - xScale(currentMonth)) / 2;
    })
    .attr('y', '10px')
    .style('font-family', 'Roboto, sans-serif')
    .style('font-size', '14px');
```

Теперь добавим ось **y**. Для этого используем генератор осей **d3.axisLeft()**, потому что ось **y** должна располагаться на левой стороне диаграммы. Передадим генератору **yScale** и сохраним ось в константе с именем **leftAxis**:

```js
const leftAxis = d3.axisLeft(yScale);
```

### Добавление меток осей

В проектах D3 метки - это простые текстовые элементы, поэтому нужно лишь добавить текстовый элемент в контейнер SVG. Присвоим ему значение "Температура (F)" и сместим на 20px ниже начала координат контейнера SVG.

```js
// prettier-ignore
svg
  .append('text')
  .text('Температура (F)')
  .attr('y','20px');
```

## Построение линейной диаграммы

В D3 линии и кривые строятся с помощью SVG-элементов **path**, формы которых определяются их атрибутами **d**.
Внутри функции **drawLineChart()** используем связанные данные и нарисуем круг для каждой записи в наборе данных **_weekly_temperature.csv_**. Для этого добавим круги в выборку **_innerChart_**, зададим им радиус **4px** и вычислим их атрибуты местоположения (**cx**,**cy**) с использованием шкал.
Обратите внимание, что мы объявили отдельную константу **aubergine**, определяющую цвет (баклажан), и использовали её для установки атрибута **fill** кругов.

```js
const aubergine = '#75485E';
// prettier-ignore
innerChart
  .selectAll('circle')
  .data(data)
  .join('circle')
    .attr('r', 4)
    .attr('cx', (d) => xScale(d.date))
    .attr('cy', (d) => yScale(d.avg_temp_F))
    .attr('fill', aubergine);
```

### Использование генератора линий

Генератор линий **d3.line()** - это функция, принимающая горизонтальную и вертикальную координаты каждой точки данных и возвращающая атрибут **d** для SVG-элемента кривой или ломаной, проходящей через точки. Обычно в одну цепочку с генератором линий мы добавляем две функции доступа, **x()** и **y()**, которые принимают горизонтальную и вертикальную координаты точки данных соответственно.

```js
// prettier-ignore
const lineGenerator = d3.line()
  .x(d => xScale(d.date))
  .y(d => yScale(d.avg_temp_F));
```

Затем добавим элемент **path** во внутреннюю диаграмму и зададим его атрибут **d**, вызвав генератор линий и передав ему набор данных.
Чтобы нарисовать только линию, нужно присвоить атрибут **fill** значение **_none_** или **_transparent_**, а атрибуту **stroke** - значение цвета.

```js
// prettier-ignore
innerChart
  .append('path')
    .attr('d', lineGenerator(data))
    .attr('fill', 'none')
    .atrr('stroke', aubergine);
```

Чтобы преобразовать генератор линий, в генератор кривой, достаточно добавить в цепочку функцию доступа **curve()** и передать ей один из интерполяторов D3. В следующем фрагменте используется интерполятор **d3.curveCatmullRom**, который создает кубический сплайн (гладкую и гибкую кривую)

```js
// prettier-ignore
const curveGenerator = d3.line()
  .x(d => xScale(d.date))
  .y(d => yScale(d.avg_temp_F))
  .curve(d3.curveCatmullRom);
```

### Шаги по созданию линейной диаграммы

1. Иницилизировать генератор линий и включить в цепочку с ним функции доступа x() и y().
2. Добавить в цепочку к генератору линий функцию доступа curve() и передать ей интерполятор (необязательно)
3. Добавить элемент path в диаграмму и вызвать генератор линий, чтобы задать значениеего атрибута d, передав данные для визуализации в качестве аргументов

## Рисование области размаха

Добавим область размаха позади линейной диаграммы, показывающую диапазон между минимальной и максимальной температурами для каждой даты.

### Использование генератора обалсти размаха

Сначала объявим функцию-генератор области размаха и сохраним её в константе с именем **areaGenerator**.
Генератор области требуте добавить в цепочку как минимум три функции доступа.
**x()** - отвечает за вычисление горизонтальной координаты точек данных, так же как в случае с генератором линии.
Но в этом случае у нас не один набор точек данных, а два: один вдоль нижнего края области и другой верхнего края, это объясняет присутствие функций доступа **y0()** и **y1()**.

```js
// prettier-ignore
const areaGenerator = d3.area()
  .x(d => xScale(d.date))
  .y0(d => yScale(d.min_temp_F))
  .y1(d => yScale(d.max_temp_F))
  .curve(d3.curveCatmullRom);
```

После создания генератора области остается только добавить элемент **path** во внутреннюю диаграмму. Чтобы получить значение для его атрибута **d**, мы вызываем генератор области и передаем набор данных в виде аргумента.

```js
innerChart
  .append('path')
  .attr('d', areaGenerator(data))
  .attr('fill', aubergine)
  .attr('fill-opacity', 0.2);
```

### Шаги по созданию области размаха

1. Иницилизировать генератор области размаха и включить в цепочку с ним функции доступа. Например **_x(), y0(), y1()_** или **_x0(), x1() и y()_**
2. Добавить в цепочку к генератору области функцию доступа **_curve()_** и передать ей интерполятор (необязательно)
3. Добавить элемент **_path_** в диаграмму и вызвать генератор области, чтобы задать значение его атрибута **_d_**, передав данные для визуализации в качестве аргумента.

### Улучшение читаемости с помощью меток

**Метки** - это простые текстовые элементы SVG, которые можно размещать поверх визуализаций.
Сначала добавим текстовый элемент SVG во внутренюю диаграмму и заполним его содержимое строкой "Average temperature" (средняя температура) вызовом метода **_text()_**. Затем вычислим его местоположение и установим атрибуты x и y.

```js
// prettier-ignore
innerChart
  .append("text")
    .text("Средняя температура")
    .attr("x", xScale(lastDate) +10)
    .attr("y", yScale(data[data.length - 1].avg_tem_F))
    .attr("dominant-baseline", "middle")
    .attr("fill", aubergine);
```

Далее добавим метку для нижней границы области размаха, представляющей эволюцию минимальной температуры.
Стратегия очень похожа: сначала добавим текстовый элемент и присвоим ему текст "Minimum temperature" (минимальная температура)

```js
// prettier-ignore
innerChart
    .append("text")
      .text("Минимальная температура")
      .attr("x", xScale(data[data.length - 3].date) +13)
      .attr("y",yScale(data[data.length - 3].min_temp_F )+ 20)
      .attr("dominant-baseline", "hanging")
      .attr("fill", aubergine);
// prettier-ignore
innerChart
    .append('line')
      .attr('x1', xScale(data[data.length - 3].date))
      .attr('y1', yScale(data[data.length - 3].min_temp_F) + 3)
      .attr('x2', xScale(data[data.length - 3].date) + 10)
      .attr('y2', yScale(data[data.length - 3].min_temp_F) + 20)
      .attr('stroke', aubergine)
      .attr('stroke-width', 2);
```

## Рисование дуг

Дуги широко используются в круговых диаграммах, диаграммах **_"солнечные лучи"_** и диаграммах **_"роза Найтингейла"_** для визуализации соотношения отдельных величин с общей суммой, и мы тоже регулярно используем их.
**Дуги** рисуются с помощью SVG-элемента **path**.
Загрузим данные для визуализации с помощью метода **d3.csv()**, с указанием параметра **_d3.autoType_**, как делали ранее в этой главе:

```js
d3.csv('./data/daily_precipitations.csv', d3.autoType).then((data) => {
  drawArc(data);
});
```

Внутри **_drawArc()_** добавим новый контейнер SVG. Ширину и высоту контейнера устанавливаются равными 300, и затем добавляются внутрь **div** с идентификатором **arc**, уже существующим в **index.html**. Чтобы сделать SVG адаптивным, установим атрибут **viewBox** два последних значения установливаются равными ширине и высоте, и полностью опускаются атрибуты **width** и **height**.

```js
// prettier-ignore
const pieChartHeight = 300;
const pieChartWidth = 300;
const svg = d3
  .select('#arc')
  .append('svg')
  .attr('viewBox', [0, 0, pieChartWidth, pieChartHeight]);
```

### Полярная система координат

**Дуги** используют **полярную систему** координа, а не декартову.
**Двумерная полярная система** координат тоже использует два измерения: **_радиус_** и **_угол_**. **Радиус** - это расстояние от начала координат до точки в пространстве, а угол отсчитывается от 12 часов по часовой стрелке. Такой способ описания положений в пространстве особенно удобен при работе с дугами.
Включение дуг в группу (**g**) SVG и последующее перемещение группы в центр контейнера SVG упрощает создание набора дуг. При добавлении новых дуг в группу они автоматически будут позиционироваться относительно центра диаграммы - начала полярной системы координат.
Следующий фрагмент использует выборку с контейнером SVG, чтобы добавить группу внутрь него. Затем группа перемещается в центр контейнера SVG и сохраняется в константе **innerChart**:

```js
// prettier-ignore
const innerChart = svg
  .append("g")
    .attr("transform", `translate(${pieChartWidth/2}, ${pieChartHeight/2})`);
```

Узнаем общее количество дней в 2021 году с помощью свойства length набора данных (оно равно 365). Затем найдем количество дней с осадками, отфильтровав набор данных и оставив только дни, в которые количество осадков больше 0, что составляет 126 дней. Наконец, мы превратим количество дней с осадками в процент, разделив его на общее количество дней, что дает 35%.

```js
const numberOfDays = data.length;
const numberOfDayesWithPrecipitation = data.filter(
  (d) => d.total_precip_in > 0
).length;
const percentageDaysWithPrecipitation = Math.round(
  (numberOfDayesWithPrecipitation / numberOfDays) * 100
);
```

Затем вычислим угол, соответствующий количеству дней с осадками, умножим полученное число на 360 градусов (количество градусов в полной окружности) и получим 126 градусов.
**_Преобразование градусов в радианы - для этого умножим угол 126, соответствующий количеству дней с осадками, на число Пи (3,1416) и разделим на 180._** В результате получаем примерно 2,2 радиана. Это значение сохраняем в константе **angleDaysWithPrecipitation_rad**.
Это преобразование необходимо, чтобы воспользоваться генератором дуг, который принимает углы в радианах, а не в градусах.

```js
const angleDaysWithPrecipitation_deg =
  (percentageDaysWithPrecipitation * 360) / 100;
const angleDaysWithPrecipitation_rad =
  (angleDaysWithPrecipitation_deg * Math.PI) / 180;
```

### Использование генератора дуг

**Генератор дуг d3.arc()** находится в модуле d3-shape и требует двух основных функций доступа: **_внутреннего_** и **_внешнего радиуса дуг_**, которым соотвествуют функции доступа **innerRadius()** и **outerRadius()** со значением 80 и 120 пикселей.

```js
// prettier-ignore
const arcGenerator = d3.arc()
  .innerRadius(80)
  .outerRadius(120);
```

Визуально отделить дуги друг от друга можно, добавив отступ между ними с помощью функции доступа **padAngle()**, которая принимает угол в радианах. Здесь мы используем отступ, равный 0,02 радиана, т.е. немного больше 1 градуса. Также можно скруглить углы дуг с помощью функции **cornerRadius()**, которая принимает значение в пикселях. Она дает тот же эффект, что и CSS-свойство **border-radius**:

```js
// prettier-ignore
const arcGenerator = d3.arc()
  .innerRadius(80)
  .outerRadius(120)
  .padAngle(0.02)
  .cornerRadius(6);
```

В следующем фрагменте мы сначала добавляем элемент **path** в выборку с внутренней диаграммой. Затем устанавливаем его атрибут **d**, вызывая генератор дуг, объявленный в предыдущем фрагменте.
Начальный и конечный углы передаются генератору в виде объекта. Значение **startAngle** равно **_0_**, что соответствует 12 часам, а значение **endAngle** - это угол, соответствующий дням с осадками, рассчитанный ранее. Наконец, мы устанавливаем цвет заливки дуги равным #6EB7C2

```js
// prettier-ignore
innerChart
  .append("path")
    .attr("d", () => {
      return arcGenerator({
        startAngle: 0,
        endAngle: angleDaysWithPrecipitation_rad
      });
    })
    .attr("fill", "#6EB7C2");
```

Анологично добавляется вторая дуга. На этот раз дуга начинается там, где закончилась предыдущая, и заканчивается в конце окружности, что соответствует угла **2\*Pi** в радианах. Для этой дуги устанавливается цвет заливки #DCE2E2, чтобы показать, что это дни без осадков:

```js
innerChart
  .append('path')
  .attr('d', () => {
    return arcGenerator({
      startAngle: angleDaysWithPrecipitation_rad,
      endAngle: 2 * Math.PI,
    });
  })
  .attr('fill', '#DCE2E2');
```

### Шаги по созданию дуг

1. Инициализировать генератор дуг и задать его внешний вид и поведение с помощью функций доступа, таких как **innerRadius()**, **outerRadius()**, **padAngle()** и **cornerRadius()**.
2. Добавить элемент **path** в диаграмму и вызвать генератор дуг, чтобы задать значение его атрибута **d**, передав **startAngle** и **endAngle** в качестве аргументов.

### Вычисление центра дуги

Отличным местом для размещения метки является центр дуги, также известный как **центроид**. Получить координаты центра можно с помощью генератора дуги.
На этот раз мы добавляем в цепочку функции доступа **startAngle()** и **endAngle()**, передавая им соответствующие значения начального и конечного углов дуги, представляющей дни с осадками, и затем метод **centroid()**, вычисляющий координаты середины:

```js
// prettier-ignore
const centroid = arcGenerator
  .startAngle(0)
  .endAngle(angleDaysWithPrecipitation_rad)
  .centroid();
```

В следующем фрагменте мы создаем метку, добавляя текстовый элемент во внутреннюю диаграмму. Чтобы добавить в метку знак "%", мы использовали метод **d3.format(".0%")**, за которым следует значение в скобках.
Затем мы устанавливаем атрибуты **x** и **y**, используя первое и второе значения из массива **centroid**. Также устанавливаем атрибуты **text-anchor** и **dominant-baseline**, чтобы гарантировать центрирование метки по атрибутам **x** и **y** как по горизонтали, так и по вертикали.
Наконец, для удобочитаемости придаем метке белый цвет и толщину шрифта 500.

```js
// prettier-ignore
innerChart
  .append('text')
    .text(d => d3.format(".0%")(percentageDaysWithPrecipitation/100))
    .attr("x", centroid[0])
    .attr("y", centroid[1])
    .attr('text-anchor', "middle")
    .attr("dominant-baseline", "middle")
    .attr('fill', 'white')
    .style('font-weight', '500');
```
