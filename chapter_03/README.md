# Работа с данными

### Загрузка набора данных в проект D3

Загрузка данных из источника (папка data) с помощью функции ` d3.csv()`, передав ей путь к файлу в первом параметре. Так как файл данных находится в папке /data, относительный путь к нему из **main.js** выглядит так: **_../data/data.csv_**. Здесь две точки ("..") - обозначают каталог уровнем выше текущего.

```js
d3.csv('../data/data.csv');
```

Важно знать, что загрузка данных - это **_асинхронный процесс_**.
**Асинхронные операции** - это запросы, результат которых недоступен немедленно.

### Форматирование набора данных

Функцию обратного вызова, что передается в **d3.csv()**, также называют **_функцией преобразования записей_**, потому что она получает доступ к данным построчно.
В следующем фрагменте первый аргумент d3.csv() - это **_путь к данным_**, а второй - **_функция обратного вызова_**, которая выводит данные в консоль.

```js
d3.csv('../data/data.csv', (d) => {
  console.log(d);
});
```

Обратите внимание, что значения из столбца **_count_** извлечены как строки, а не числа. Это распространенная проблема при импорте данных, связанная с преобразованием набора данных из формата CSV в формат JSON.
Поэтому, в следующем фрагменте вместо вывода каждой строки данных в консоль мы возвращаем объект, содержащий пары ключ-значение

```js
d3.csv('../data/data.csv', (d) => {
  return {
    technology: d.technology,
    count: +d.count,
  };
});
```

### Оценка набора данных

Для возможности иметь доступ к набору данных в целом, можно воспользоваться JS-объектом **Promise**.
Объект **Promise** - это результат выполнения асинхронной операции, такой как **_d3.csv()_**. Самый простой способ извлечь данные из **Promise** - использовать метод **_then()_**.

```js
d3.csv('../data/data.csv', (d) => {
  return {
    technology: d.technology,
    count: +d.count,
  };
}).then((data) => {
  console.log(data);
});
```

Методы для оценки данных: d3.max(), d3.min(), d3.extent()

```js
d3.max(data, (d) => d.count); // максимальное значение
d3.min(data, (d) => d.count); // минимальное значение
d3.extent(data, (d) => d.count); // возвращает массив с минимальным и максимальным занчениями. [20, 1078]
```

Метод сортировки данных в порядке убывания sort()

```js
data.sort((a, b) => b.count - a.count);
```

Все методы оценки данных запускаются все в том же методе then()

### Промежуточный результат

```js
d3.csv('data/data.csv', (d) => {
  return {
    technology: d.technology,
    count: +d.count,
  };
})
  .then((data) => {
    console.log(
      'Максимальное значение',
      d3.max(data, (d) => d.count)
    );
    console.log(
      'Минимальное значение',
      d3.min(data, (d) => d.count)
    );
    console.log(
      'Минимальное и максимальное значение в массиве',
      d3.extent(data, (d) => d.count)
    );
    return data.sort((a, b) => b.count - a.count); // сортировка по убыванию
  })
  .then(console.log);
```

### Привязка данных к элементам DOM

Чтобы привязать данные, достаточно просто использовать шаблон, показанный ниже, который состоит из вызовов трех методов (**_ selectAll(), data(), join()_**)

1. С помощью метода **_selectAll("rect")_** создаем так называемую **_пустую выборку_** (т.к. с помощью метода выбераются не существующие элементы в DOM дереве)

```js
svg.selectAll('rect');
```

2. Далее мы включаем в цепочку вызов метода **_data()_** и передаем ему набор данных. Теперь **D3** знает, что должна создать один элемент **rect** для каждой записи в данных:

```js
svg.selectAll('rect').data(data);
```

3. В заключении добавляем вызов **_join()_**, который вставит прямоугольники в DOM:

```js
svg.selectAll('rect').data(data).join('rect');
```

### Динамическая настройка атрибутов DOM с помощью данных

В конце шаблона привязки данных добавляем вызов метода **_attr()_**, который будет применен к выборке, содержащей прямоугольники.

```js
const barHeight = 20;
svg
  .selectAll('rect')
  .data(data)
  .join('rect')
  .attr('class', (d) => {
    return `bar bar-${d.technology}`;
  })
  .attr('width', (d) => d.count)
  .attr('height', barHeight);
```

Для прямоугольника одним из основных атрибутов является его ширина - **width** и его длинна - **height**. Так как наши прямоугольники необходимо разместить горизонтально, то для **width** будет присвоено значение **_count_** из массива данных, а для всех прямоугольников длинна **height** будет установлена постоянное значение **_barHeight = 20_**

```js
svg
  .selectAll('rect')
  .data(data)
  .join('rect')
  .attr('class', (d) => {
    return `bar bar-${d.technology}`;
  });
```

Далее нам нужно задать позиции прямоугольников, вычислив координаты верхних левых углов и поместить их в атрибуты **x** и **y**.

```js
svg
  .selectAll('rect')
  .data(data)
  .join('rect')
  .attr('class', (d) => {
    return `bar bar-${d.technology}`;
  })
  .attr('width', (d) => d.count)
  .attr('height', barHeight)
  .attr('x', 0)
  .attr('y', (d, index) => {
    return index * (barHeight + 10);
  });
```

## Адаптация данных под размеры экрана

Создавая **_визуализации_**, мы преобразуем **_данные_** в **_визуальные характеристики_**, такие как **_размер элемента_**, **_цвет_** или **_местоположение_** на экране.
В проектах **D3** это преобразование выполняется с помощью **_шкал_**.

## Шкалы

**Шкалы** - это функции, принимающие значение из фактических данных и возвращающие результат, который можно напрямую использовать для установки размера, местоположения или цвета элемента визуализации.
Более конкретно, входные данные являются частью **_предметной облости (domain)_**, определяющий спектр возможных значений в данных.
На экране эта предметная область отображается в выходной **_диапазон (range)_**, определяющий спектр возможных выходных значений.

В D3 есть несколько функций шкал. Возьмем для примера функцию линейной шкалы **_d3.scaleLinear()_**.
Чтобы **_инициализировать_** функцию шкалы, нужно связать методы **_domain()_** и **_range()_**.

```js
const myScale = d3.scaleLinear().domain([0, 200]).range([0, 20]);
```

Входные и выходные значения шкалы могут быть **_непрерывными_** или **_дискретными_**.
В D3 **_количественные данные_** обычно связваются со шкалой с **_непрерывной предметной областью_**. **_Качественные данные_**, наоборот, подразумевают **_дискретность предметной области_**, обычно представляемой в виде массива возможных значений. Следовательно, шкала с непрерывным диапазоном выходных значений может вернуть любое значение в указанных пределах, тогда как шкала с дискретным диапазоном будет возварщать значения только из предопределенного списка.
Основываясь на этих понятиях **_непрерывных_** и **_дискретных_** входных и выходных данных, шкалы D3 можно сгруппировать в четыре семейства:

1. Шкалы с непрерывными входными и выходными данными;
2. Шкалы с дискретными входными и выходными данными;
3. Шкалы с непрерывными входными и дискретными выходными данными;
4. Шкалы с дискретынми входными и непрерывными выходными данными.

### Линейная шкала

Чаще всего в проектах D3 используется линейная шкала (**_d3.scaleLinear()_**). Она принимает непрерывную предметную область на входе данных и возвращает непрерывный диапазон на выходе:

```js
const myLinearScale = d3.scaleLinear().domain([0, 250]).range([0, 25]);
```

Возвращаемся к нашему примеру. Сначала объявим константу с именем **_xScale_**. Эта шкала будет отвечать за размер и позиционирование элементов по оси **х**.
Затем вызовем функцию **_d3.scaleLinear()_** и добавим в цепочку методы **_domain()_** и **_range()_**.
Добавим линейную шкалу внутри функции **createViz()** перед привязкой данных:

```js
// prettier-ignore
const createViz = (data) => {
  const xScale = d3.scaleLinear()
                .domain([0, 1078])
                .range([0,450]);

  // Привязка данных
  ...
}
```

Теперь, объявив шкалу, её можно использовать для вычисления ширины каждого прямоугольника в нашей диаграмме.
В строке кода, где задается атрибут **_width_** прямоугольников, вместо использования значения **_count_** напрямую вызовим нашу шкалу
**_xScale()_** и передадим значение **_count_** в качестве аргумента:

```js
svg
      .selectAll('rect')
      .data(data)
      .join('rect')
        ...
        .attr("width", d => xScale(d.count))
        ...
        .attr("x",100) // смещение по оси Х на 100px
        ...
```

### Интервальная шкала

Интервальные шкалы относятся к четвертому семейству: они принимают дискретные и возвращают непрерывные данные. Интервальную шкалу удобно испоьзовать для равномерного распределения прямоугольников столбчатой диаграммы в пределах доступного пространства.
Чтобы объявить интервальную шкалу, нужно вызвать функцию **_d3.scaleBand()_**. Добавим интервальную шкалу внутрь **createViz()** перед привязкой данных.

```js
// prettier-ignore
const yScale = d3
  .scaleBand()
  .domain(data.map((d) => d.technology))
  .range([0, 700])
```

Благодаря интервальной шкале мы теперь можем с легкостью задать атрибуты у прямоугольников

```js
// prettier-ignore
svg
  .selectAll('rect')
  .data(data)
  .join("rect")
    ...
    .attr("y", d => yScale(d.technology))
    ...
```

Интервальные шкалы также имеют очень удобный метод **_bandwidth()_**, возвращает высоту прямоугольников, которая пропорциональна количеству прямоугольников и доступному пространству. В следующем фрагменте показано, как вызовом метода **_bandwidth()_** интервальной шкалы можно получить значение для атрибута **height()**:

```js
// prettier-ignore
svg
  .selectAll("rect")
  .data(data)
  .join("rect")
    ...
    .attr("height", yScale.bandwidth())
    ...
```

Для добавления отступа между прямоугольниками необходимо установить свойство **_paddingInner()_** интервальной шкалы.
**_paddingInner()_** принимает значения от **0** до **1**.

```js
// prettier-ignore
const yScale = d3.scaleBand()
                .domain(data.map(d => d.technology))
                .range([0,700])
                .paddingInner(0.2) // 0.2 - составляет 20% от высоты прямоугольника
```

### Добавление меток на диаграмму

Добавим два набора меток. Первый набор будет содержать названия технологий, перечисленных с левой стороны. Второй - значения счетчиков, связанных с каждым столбцом и расположенных на концах прямоугольников.
В визуализациях на основе SVG метки создаются с помощью текстовых элементов. Мы объединим с каждым прямоугольником два текстовых элемента и вложим каждый прямоугольник с его метками в группу SVG.

### Итоговый вариант функции createViz

```js
// prettier-ignore
const createViz = (data) =>{
    const xScale = d3.scaleLinear().domain([0, 1078]).range([0,450]);
    const yScale = d3.scaleBand().domain(data.map(d => d.technology)).range([0,700]).paddingInner(0.2);

    const barAndLabel = svg
      .selectAll('g')
      .data(data)
      .join('g')
        .attr("transform", d =>`translate(0,${yScale(d.technology)})`);

    barAndLabel
      .append("rect")
        .attr("class", d => {return `bar bar-${d.technology}`})
        .attr("width", d => xScale(d.count))
        .attr("height", yScale.bandwidth())
        .attr("x",100) // смещение по оси Х на 100px
        .attr("y", 0) // Прямоугольники больше не нуждаются в позиционировании по вертикали. Положение определяется по родительской группе
        .attr("fill", d => d.technology === "D3.js" ? "yellowgreen": "skyblue");

    // Добавляем первую группу меток - название технологий
    barAndLabel
      .append("text")
        .text(d => d.technology)
        .attr("x", 96)
        .attr("y", 12)
        .attr("text-anchor", "end")
        .style("font-family","sans-serif")
        .style("font-size", "11px");

    // Добавляем вторую группу меток - сколько раз каждая технология была выбрана в опросе
    barAndLabel
      .append("text")
        .text(d => d.count)
        .attr("x", d => 100 + xScale(d.count) + 4)
        .attr("y", 12)
        .style("font-family", "sans-serif")
        .style("font-size", "9px");
        
    // Добавляем вертикальную линию
    svg
      .append("line")
        .attr("x1",100)
        .attr("y1",0)
        .attr("x2", 100)
        .attr("y2",700)
        .attr("stroke", "black");
  }
```

### Конечный результат в main.js

```js
// prettier-ignore
// prettier-ignore
(() => {
  const svg = d3.select('.responsive-svg-container')
    .append('svg')
      .attr('viewBox', '0 0 600 700')
      .style('border','1px solid black');

  // Функция привязки данных к DOM элементам
  const createViz = (data) =>{
    const barHeight = 20;
    const xScale = d3.scaleLinear().domain([0, 1078]).range([0,450]);
    const yScale = d3.scaleBand().domain(data.map(d => d.technology)).range([0,700]).paddingInner(0.2);

    const barAndLabel = svg
      .selectAll('g')
      .data(data)
      .join('g')
        .attr("transform", d =>`translate(0,${yScale(d.technology)})`);

    barAndLabel
      .append("rect")
        .attr("class", d => {return `bar bar-${d.technology}`})
        .attr("width", d => xScale(d.count))
        .attr("height", yScale.bandwidth())
        .attr("x",100) // смещение по оси Х на 100px
        .attr("y", 0) // Прямоугольники больше не нуждаются в позиционировании по вертикали. Положение определяется по родительской группе
        .attr("fill", d => d.technology === "D3.js" ? "yellowgreen": "skyblue");

    // Добавляем первую группу меток - название технологий
    barAndLabel
      .append("text")
        .text(d => d.technology)
        .attr("x", 96)
        .attr("y", 12)
        .attr("text-anchor", "end")
        .style("font-family","sans-serif")
        .style("font-size", "11px");

    // Добавляем вторую группу меток - сколько раз каждая технология была выбрана в опросе
    barAndLabel
      .append("text")
        .text(d => d.count)
        .attr("x", d => 100 + xScale(d.count) + 4)
        .attr("y", 12)
        .style("font-family", "sans-serif")
        .style("font-size", "9px");
        
    // Добавляем вертикальную линию
    svg
      .append("line")
        .attr("x1",100)
        .attr("y1",0)
        .attr("x2", 100)
        .attr("y2",700)
        .attr("stroke", "black");
  }

  d3.csv("data/data.csv", d => {
    return {
      technology: d.technology,
      count: +d.count
    }
  }).then(data => {
    console.log('Максимальное значение', d3.max(data, d => d.count));
    console.log('Минимальное значение', d3.min(data, d => d.count));
    console.log('Минимальное и максимальное значение в массиве', d3.extent(data, d => d.count));
    return data.sort((a,b) => b.count - a.count) // сортировка по убыванию

  }).then(data => createViz(data)).then(console.log)
})();
```

## Справка

Шаблонные литералы - это шаблонные строки, заключенные в обратные ковычки **(``)**

```js
`bar bar-${d.technology}`; // шаблонные литералы
```

Они используются для объединения традиционных строк JS с выражениями. **Выражения** предваряются символом доллара и заключаются в фигурные скобки (${expression})
